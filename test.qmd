```{python}
import numpy as np
import rasterio

def process_tifs(input_tif, mask_tif, output_tif):
    with rasterio.open(input_tif) as src:
        input_data = src.read(1)
        input_transform = src.transform
        input_crs = src.crs

    with rasterio.open(mask_tif) as msk:
        mask_data = msk.read(1)
        mask_transform = msk.transform

    # Calculate the scaling factors between the two rasters
    scale_x = int(input_transform[0] / mask_transform[0])
    scale_y = int(input_transform[4] / mask_transform[4])

    # Reshape the input data to match the mask data resolution
    input_data_rescaled = np.repeat(np.repeat(input_data, scale_y, axis=0), scale_x, axis=1)

    # Calculate the percentage of pixels with value 1 in each region
    region_sums = np.add.reduceat(np.add.reduceat(mask_data, np.arange(0, mask_data.shape[0], scale_y), axis=0),
    np.arange(0, mask_data.shape[1], scale_x), axis=1)
    percentages = region_sums / (scale_x * scale_y)

    # Calculate the new values for each region
    new_values = np.nan_to_num(input_data / percentages)

    # Assign these values to the corresponding pixels in the output raster
    output_data = new_values.repeat(scale_y, axis=0).repeat(scale_x, axis=1) * (mask_data == 1)

    # Write the output raster
    with rasterio.open(output_tif, 'w', driver='GTiff', height=output_data.shape[0],
                       width=output_data.shape[1], count=1, dtype=str(output_data.dtype),
                       crs=input_crs, transform=mask_transform, compress='lzw') as dst:
        dst.write(output_data, 1)

```



```{python}
import numpy as np
import rasterio

def add_remove_rows(input_tif, output_tif, top, bottom, left, right):
    with rasterio.open(input_tif) as src:
        original_array = src.read()
        original_meta = src.meta
        input_top_left_x = src.transform[2]
        input_top_left_y = src.transform[5]
        input_pixel_width, input_pixel_height = src.res

    # Calculate the new dimensions
    new_height = original_meta['height'] + top + bottom
    new_width = original_meta['width'] + left + right

    # If rows or columns are being removed, adjust the start indices for slicing the original array
    start_row = -top if top < 0 else 0
    start_col = -left if left < 0 else 0

    # Similarly, adjust the end indices for slicing the original array
    end_row = original_meta['height'] if bottom >= 0 else bottom
    end_col = original_meta['width'] if right >= 0 else right

    # Slice the original array based on the calculated indices
    adjusted_array = original_array[:, start_row:end_row, start_col:end_col]

    # Create a new array with the desired dimensions and copy the data from the adjusted array into it
    new_array = np.zeros((original_array.shape[0], new_height, new_width), dtype=original_array.dtype)
    new_array[:, max(0, top):max(0, top)+adjusted_array.shape[1], max(0, left):max(0, left)+adjusted_array.shape[2]] = adjusted_array

    # Calculate the updated geotransform
    new_transform = original_meta['transform']
    new_transform = rasterio.Affine(new_transform.a, new_transform.b, new_transform.c - abs(left) * new_transform.a, new_transform.d, new_transform.e, new_transform.f - abs(top) * new_transform.e)

    # Update the metadata to reflect the new shape and georeferencing
    new_meta = original_meta.copy()
    new_meta.update({
        'height': new_height,
        'width': new_width,
        'transform': new_transform,
        'compress': 'lzw'
    })

    # Write the new array to a new GeoTIFF with LZW compression
    with rasterio.open(output_tif, 'w', **new_meta) as dst:
        dst.write(new_array)


```



```{python}
import numpy as np
import rasterio

def adjust_geotiff(input_tif, target_tif, output_tif):
    with rasterio.open(input_tif) as src:
        original_array = src.read()
        original_meta = src.meta
        input_top_left_x = src.transform[2]
        input_top_left_y = src.transform[5]
        input_pixel_width, input_pixel_height = src.res
        

    with rasterio.open(target_tif) as tgt:    
        target_top_left_x = tgt.transform[2]
        target_top_left_y = tgt.transform[5]
        target_height_m = abs(tgt.transform[4]) * tgt.height
    
    desired_y_movement = target_top_left_y - input_top_left_y
    desired_y_movement_in_pixel_amount = int(desired_y_movement // input_pixel_height)
    top = desired_y_movement_in_pixel_amount


    desired_x_movement = target_top_left_x - input_top_left_x
    desired_x_movement_in_pixel_amount = int((desired_x_movement // input_pixel_width)*-1)
    left = desired_x_movement_in_pixel_amount

    total_height = round((target_height_m // input_pixel_height) / tgt.height) * tgt.height
    bottom = total_height - top - src.height
    
    total_width = int(total_height/tgt.height*tgt.width)
    right = total_width - src.width - left

    # Calculate the new dimensions
    new_height = original_meta['height'] + top + bottom
    new_width = original_meta['width'] + left + right

    # If rows or columns are being removed, adjust the start indices for slicing the original array
    start_row = -top if top < 0 else 0
    start_col = -left if left < 0 else 0

    # Similarly, adjust the end indices for slicing the original array
    end_row = original_meta['height'] if bottom >= 0 else bottom
    end_col = original_meta['width'] if right >= 0 else right

    # Slice the original array based on the calculated indices
    adjusted_array = original_array[:, start_row:end_row, start_col:end_col]

    # Create a new array with the desired dimensions and copy the data from the adjusted array into it
    new_array = np.zeros((original_array.shape[0], new_height, new_width), dtype=original_array.dtype)
    new_array[:, max(0, top):max(0, top)+adjusted_array.shape[1], max(0, left):max(0, left)+adjusted_array.shape[2]] = adjusted_array

    # Calculate the updated geotransform
    new_transform = original_meta['transform']
    new_transform = rasterio.Affine(new_transform.a, new_transform.b, new_transform.c - abs(left) * new_transform.a, new_transform.d, new_transform.e, new_transform.f - abs(top) * new_transform.e)

    # Update the metadata to reflect the new shape and georeferencing
    new_meta = original_meta.copy()
    new_meta.update({
        'height': new_height,
        'width': new_width,
        'transform': new_transform,
        'compress': 'lzw'
    })

    # Write the new array to a new GeoTIFF with LZW compression
    with rasterio.open(output_tif, 'w', **new_meta) as dst:
        dst.write(new_array)


```


```{python}
from rasterio.transform import from_origin


def distort_geotiff(input_path, target_tif, output_path):
    # Open the target GeoTIFF to extract the target coordinates
    with rasterio.open(target_tif) as target_src:
        target_transform = target_src.transform
        # Get the target coordinates of the upper-left and lower-right corners
        x0, y0 = target_transform * (0, 0)
        x1, y1 = target_transform * (target_src.width, target_src.height)

    # Open the input GeoTIFF
    with rasterio.open(input_path) as src:
        # Get the metadata and data from the input GeoTIFF
        metadata = src.meta
        data = src.read()

        # Calculate the transformation parameters for the output GeoTIFF
        # Adjust the x0, y0, x1, and y1 values to align with the target GeoTIFF
        transform = from_origin(x0, y0, metadata['transform'].a, -metadata['transform'].e)

        # Create a new metadata dictionary for the output
        output_meta = metadata.copy()
        output_meta.update({
            'transform': transform,
            'compress': 'lzw'
        })

        # Create an output GeoTIFF
        with rasterio.open(output_path, 'w', **output_meta) as dst:
            # Write the data to the output GeoTIFF
            dst.write(data)
```

```{python}
def rescale_tif(input_tif, mask_tif, output_tif):
    with rasterio.open(input_tif) as src:
        input_data = src.read(1)
        input_transform = src.transform
        input_crs = src.crs

    with rasterio.open(mask_tif) as msk:
        mask_transform = msk.transform

    # Calculate the scaling factors between the two rasters
    scale_x = int(input_transform[0] / mask_transform[0])
    scale_y = int(input_transform[4] / mask_transform[4])

    # Reshape the input data to match the mask data resolution
    input_data_rescaled = np.repeat(np.repeat(input_data, scale_y, axis=0), scale_x, axis=1)

    # Write the output raster with the rescaled data
    with rasterio.open(output_tif, 'w', driver='GTiff', height=input_data_rescaled.shape[0],
                       width=input_data_rescaled.shape[1], count=1, dtype=str(input_data_rescaled.dtype),
                       crs=input_crs, transform=mask_transform, compress='lzw') as dst:
        dst.write(input_data_rescaled, 1)
```

```{python}
input_tif = 'soybean_distorted.tif'
mask_tif = 'cropland_2015_added_rows.tif'
output_tif = 'soybean_rescaled.tif'

process_tifs(input_tif, target_tif, output_tif)

```

# test with minimal example

```{python}
input_tif = 'small_pixel.tif'
target_tif = 'large_pixel_moved.tif'
output_tif = 'small_pixel_added_rows.tif'

adjust_geotiff(input_tif, target_tif, output_tif)

```


```{python}
input_tif = 'large_pixel.tif'
target_tif = 'small_pixel_added_rows.tif'
output_tif = 'large_pixel_distorted.tif'
distort_geotiff(input_tif, target_tif, output_tif)
```

```{python}
input_tif = 'large_pixel_distorted.tif'
mask_tif = 'small_pixel_added_rows.tif'
output_tif = 'pixel_combined.tif'

process_tifs(input_tif, mask_tif, output_tif)
```


```{python}
import numpy as np
import rasterio
from rasterio.enums import Resampling

def process_tifs(input_tif_path, target_tif_path, output_tif_path):
    with rasterio.open(input_tif_path) as input_tif:
        with rasterio.open(target_tif_path) as target_tif:
            # Resample input to match target's resolution
            data = input_tif.read(
                out_shape=(
                    input_tif.count,
                    target_tif.height,
                    target_tif.width
                ),
                resampling=Resampling.nearest
            )

            # Calculate new values for each region
            for i in np.unique(data):
                mask = (target_tif.read(1) == 1) & (data == i)
                percent = np.sum(mask) / np.sum(data == i)
                data[mask] = i * (100 / percent)

            # Write output to a new GeoTIFF file
            with rasterio.open(
                output_tif_path,
                'w',
                driver='GTiff',
                height=target_tif.height,
                width=target_tif.width,
                count=1,
                dtype=data.dtype,
                crs='+proj=latlong',
                transform=target_tif.transform,
                compress='lzw'
            ) as output_tif:
                output_tif.write(data)



```

```{python}
input_tif = 'large_pixel_distorted.tif'
mask_tif = 'small_pixel_added_rows.tif'
output_tif = 'pixel_combined.tif'

process_tifs(input_tif, mask_tif, output_tif)
```


# test with borneo data
##
```{python}
input_tif = '/Users/robinpfaff/Library/CloudStorage/OneDrive-ZHAW/6_Semester/BA/07_data_prepared/cropland/LAEA_borneo_cropland_2015.tif'
target_tif = '/Users/robinpfaff/Library/CloudStorage/OneDrive-ZHAW/6_Semester/BA/07_data_prepared/crop_type/crops_2015/LAEA/LAEA_GAEZAct2015_HarvArea_Soybean_Total.tif'
output_tif = 'cropland_2015_added_rows.tif'

adjust_geotiff(input_tif, target_tif, output_tif)

```


```{python}
input_tif = '/Users/robinpfaff/Library/CloudStorage/OneDrive-ZHAW/6_Semester/BA/07_data_prepared/crop_type/crops_2015/LAEA/LAEA_GAEZAct2015_HarvArea_Soybean_Total.tif'
target_tif = 'cropland_2015_added_rows.tif'
output_tif = 'soybean_distorted.tif'
distort_geotiff(input_tif, target_tif, output_tif)
```

```{python}
input_tif = 'distorted.tif'
mask_tif = 'cropland_2015_added_rows.tif'
output_tif = 'combined.tif'

process_tifs(input_tif, mask_tif, output_tif)
```



```{python}
from rasterio import warp
import numpy as np
def adjust_geotiff_extent(input_tif_path, target_tif_path, output_tif_path):
    # Open the input and target TIFs
    with rasterio.open(input_tif_path) as input_src, rasterio.open(target_tif_path) as target_src:
        # Read the input TIF as a NumPy array
        input_data = input_src.read()

        # Get the top-left and bottom-right coordinates of the target TIF
        target_top_left = (target_src.bounds.left, target_src.bounds.bottom)  # Flip y-coordinate
        target_bottom_right = (target_src.bounds.right, target_src.bounds.top)  # Flip y-coordinate

        # Calculate the new transformation matrix based on the coordinates of the target TIF
        new_transform = rasterio.transform.from_bounds(*target_top_left, *target_bottom_right, input_src.width, input_src.height)

        # Write the data to a new TIF file with the adjusted extent
        with rasterio.open(output_tif_path, 'w', driver='GTiff', height=input_src.height, width=input_src.width,
                           count=input_src.count, dtype=input_data.dtype, crs=target_src.crs, transform=new_transform) as output_dst:
            output_dst.write(input_data)
```

```{python}
input_tif = 'large_pixel_moved.tif'
target_tif = 'small_pixel.tif'
output_tif = 'large pixel_distorted.tif'
adjust_geotiff_extent(input_tif, target_tif, output_tif)
```


```{python}

input_tif = 'soybean_distorted.tif'
mask_tif = 'cropland_2015_added_rows.tif'
output_tif = 'combined.tif'

with rasterio.open(input_tif) as src:
    input_data = src.read(1)
    input_transform = src.transform
    input_crs = src.crs

with rasterio.open(mask_tif) as msk:
    mask_data = msk.read(1)
    mask_transform = msk.transform

# Calculate the scaling factors between the two rasters
scale_x = int(input_transform[0] / mask_transform[0])
scale_y = int(input_transform[4] / mask_transform[4])

# Reshape the input data to match the mask data resolution
input_data_rescaled = np.repeat(np.repeat(input_data, scale_y, axis=0), scale_x, axis=1)

# Calculate the percentage of pixels with value 1 in each region
region_sums = np.add.reduceat(np.add.reduceat(mask_data, np.arange(0, mask_data.shape[0], scale_y), axis=0),
np.arange(0, mask_data.shape[1], scale_x), axis=1)
percentages = region_sums / (scale_x * scale_y)

# Calculate the new values for each region
new_values = np.nan_to_num(input_data / percentages)

# Assign these values to the corresponding pixels in the output raster
output_data = new_values.repeat(scale_y, axis=0).repeat(scale_x, axis=1) * (mask_data == 1)

# Write the output raster
with rasterio.open(output_tif, 'w', driver='GTiff', height=output_data.shape[0],
                    width=output_data.shape[1], count=1, dtype=str(output_data.dtype),
                    crs=input_crs, transform=mask_transform, compress='lzw') as dst:
    dst.write(output_data, 1)
```

```{python}
def get_extent(tif_file):
    with rasterio.open(tif_file) as src:
        return src.bounds


print(get_extent(input_tif))
print(get_extent(mask_tif))
```
```{python}
import numpy as np
import rasterio

def rescale_tif(input_tif, mask_tif, output_tif):
    with rasterio.open(input_tif) as src:
        input_data = src.read(1)
        input_transform = src.transform
        input_crs = src.crs

    with rasterio.open(mask_tif) as msk:
        mask_transform = msk.transform

    # Calculate the scaling factors between the two rasters
    scale_x = int(input_transform[0] / mask_transform[0])
    scale_y = int(input_transform[4] / mask_transform[4])

    # Reshape the input data to match the mask data resolution
    input_data_rescaled = np.repeat(np.repeat(input_data, scale_y, axis=0), scale_x, axis=1)

    # Calculate the new transform
    new_transform = rasterio.Affine(input_transform[0] / scale_x,
                                    input_transform[1],
                                    input_transform[2],
                                    input_transform[3],
                                    input_transform[4] / scale_y,
                                    input_transform[5])

    # Write the output raster
    with rasterio.open(output_tif, 'w', driver='GTiff', height=input_data_rescaled.shape[0],
                       width=input_data_rescaled.shape[1], count=1, dtype=str(input_data_rescaled.dtype),
                       crs=input_crs, transform=new_transform, compress='lzw') as dst:
        dst.write(input_data_rescaled, 1)

```

```{python}
input_tif = 'distorted.tif'
mask_tif = 'cropland_2015_added_rows.tif'
output_tif = 'combined.tif'

rescale_tif(input_tif, mask_tif, output_tif)
```



```{python}
import numpy as np
import rasterio

def create_empty_tif(input_tif, output_tif):
    with rasterio.open(input_tif) as src:
        input_data = src.read(1)
        input_transform = src.transform
        input_crs = src.crs

    # Create an array of zeros with the same shape as the input data
    output_data = np.zeros_like(input_data)

    # Write the output raster
    with rasterio.open(output_tif, 'w', driver='GTiff', height=output_data.shape[0],
                       width=output_data.shape[1], count=1, dtype=str(output_data.dtype),
                       crs=input_crs, transform=input_transform, compress='lzw') as dst:
        dst.write(output_data, 1)


```

```{python}
input_tif = 'combined.tif'
output_tif = 'random.tif'

create_empty_tif(input_tif, output_tif)
```


```{python}

import rasterio
import numpy as np
from skimage import transform

def align_tif(input_tif, reference_tif, output_tif):
    with rasterio.open(input_tif) as src:
        input_data = src.read(1)
        input_transform = src.transform
        input_crs = src.crs
        

    with rasterio.open(reference_tif) as ref:
        ref_transform = ref.transform
        ref_pixel_width, ref_pixel_height = ref.res


    pixel_size = (ref_pixel_width * ref.width) / src.width

    # Create an affine transformation with the new pixel size
    tform = transform.AffineTransform(scale=(pixel_size, pixel_size))

    # Apply the transformation to the input data
    input_data_aligned = transform.warp(input_data, tform.inverse)

    # Create a new transform for the output data with the desired pixel size
    output_transform = rasterio.Affine(pixel_size, 0, ref_transform[2], 0, -pixel_size, ref_transform[5])

    # Write the output raster
    with rasterio.open(output_tif, 'w', driver='GTiff', height=input_data_aligned.shape[0],
                       width=input_data_aligned.shape[1], count=1, dtype=str(input_data_aligned.dtype),
                       crs=input_crs, transform=output_transform, compression='LZW') as dst:
        dst.write(input_data_aligned, 1)


import rasterio
import numpy as np
from skimage import transform

import rasterio
import numpy as np
from skimage import transform

def align_tif(input_tif, reference_tif, output_tif):
    with rasterio.open(input_tif) as src:
        input_data = src.read(1)
        input_transform = src.transform
        input_crs = src.crs

    with rasterio.open(reference_tif) as ref:
        ref_transform = ref.transform
        ref_pixel_width, ref_pixel_height = ref.res

    pixel_size = (ref_pixel_width * ref.width) / src.width

    # Create an affine transformation with the new pixel size
    tform = transform.AffineTransform(scale=(pixel_size, pixel_size))

    # Apply the transformation to the input data
    input_data_aligned = transform.warp(input_data, tform.inverse)

    # Create a new transform for the output data with the desired pixel size
    output_transform = rasterio.Affine(pixel_size, 0, ref_transform[2], 0, -pixel_size, ref_transform[5])

    # Write the output raster
    with rasterio.open(output_tif, 'w', driver='GTiff', height=input_data_aligned.shape[0],
                       width=input_data_aligned.shape[1], count=1, dtype=str(input_data_aligned.dtype),
                       crs=input_crs, transform=output_transform, compression='LZW') as dst:
        dst.write(input_data_aligned, 1)

    # Copy the values from the input TIF into an array
    input_values = np.copy(input_data)

    # Resize the input_values array to match the shape of the output TIF
    input_values_resized = transform.resize(input_values, (input_data_aligned.shape[0], input_data_aligned.shape[1]))

    # Open the output TIF and insert the values from the input TIF
    with rasterio.open(output_tif, 'r+', driver='GTiff', compression='LZW') as dst:
        dst.write(input_values_resized, 1)


```


```{python}
input_tif = 'large_pixel_moved.tif'
reference_tif = 'small_pixel_added_rows.tif'
output_tif = 'pixel_distorted.tif'

align_tif(input_tif, reference_tif, output_tif)
```

```{python}
input_tif = '/Users/robinpfaff/Library/CloudStorage/OneDrive-ZHAW/6_Semester/BA/07_data_prepared/crop_type/crops_2015/LAEA/LAEA_GAEZAct2015_HarvArea_Soybean_Total.tif'
reference_tif = 'cropland_2015_added_rows.tif'
output_tif = 'distorted.tif'

align_tif(input_tif, reference_tif, output_tif)
```